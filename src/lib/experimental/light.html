<!--
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../../../polymer.html">
<link rel="import" href="property-accessors.html">
<script>
(function() {

  function mapIdNodes(root) {
    var nodes = root.querySelectorAll('[id]');
    var map = {};

    for (var i = 0; i < nodes.length; ++i) {
      map[nodes[i].id] = nodes[i];
    }

    return map;
  }


  // Basic setup of the common base, which includes HTMLElement and
  // the backported PropertyAccessors.
  var base = Polymer.Base.extend(
      Object.create(HTMLElement.prototype),
      Polymer.PropertyAccessors.mixin);

  var light = Polymer.Base.extend(base, {
    createdCallback: function() {
      // Element will not be marked as ready until the first attached
      this.__ready = false;

      // This will set root to a document fragment, if there is a template
      // available to instance:
      this.__root = this.__template
          ? Polymer.Base.instanceTemplate(this.__template)
          : null;

      // This method is implemented by PropertyAccessors, and will set
      // properties to their initial values. Change callback should be async,
      // so it is okay to do this before mapping ID nodes:
      this._initializeProperties();

      // Properties with function values need to have their values computed
      // now, at instance time:
      for (var property in this.__dataInstance) {
        this._setProperty(property, this.__dataInstance[property].call(this));
      }

      // Collect properties from any relevant attribute values. The type
      // configured for associated properties will be used to deserialize any
      // present attribute values:
      if (this.hasAttributes()) {
        for (var property in this.properties) {
          var attribute = Polymer.CaseMap.camelToDashCase(property);

          if (this.hasAttribute(attribute)) {
            var config = this.properties[property];
            var value = this._deserializeValue(
                this.getAttribute(attribute), config.type);

            this._setProperty(property, value);
          }
        }
      }

      if (this.__root != null) {
        // Queries for nodes with ID and marshal them to the $ property:
        this.$ = mapIdNodes(this.__root);
        // No shadow root created, so we just append to the element's light
        // dom. NOTE: no style encapsulation here.
        this.appendChild(this.__root);
      }

      if (this.created != null) {
        this.created();
      }
    },

    attachedCallback: function() {
      // This may be the first attach, so we do some one-time work here to
      // set things up:
      if (this.__ready === false) {
        // Find the "owner" root, which may be a shadow root:
        var ownerRoot = this;

        while (ownerRoot
               && ownerRoot.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
          ownerRoot = ownerRoot.parentNode;
        }

        // The location where we will append styles is the owner root if
        // there is one, or else the owner document head.
        var styleParent = ownerRoot != null
          ? ownerRoot
          : this.ownerDocument.head;

        // We only want to append the stylesheet once per light element, so
        // we track the roots that have the stylesheet in a weak set:
        if (!this.__styledRoots.has(styleParent)) {
          var stylesheet = document.createElement('style');

          stylesheet.textContent = this.__cssText;
          styleParent.appendChild(stylesheet);

          this.__styledRoots.add(styleParent);
        }

        // One time readiness work is complete:
        this.__ready = true;

        if (this.ready != null) {
          this.ready();
        }
      }

      if (this.detached != null) {
        this.detached();
      }
    },

    detachedCallback: function() {
      if (this.detached != null) {
        this.detached();
      }
    }
  });


  Polymer.Light = function(implementation) {
    var proto = Object.create(light);
    var is = implementation.is;
    // Property config only observes the type and value keys
    // for any given property, e.g.
    // { propName: { type: String, value: 'propValue' } }
    var properties = implementation.properties;
    var module = Polymer.DomModule.import(is);

    // A map of all properties with functions as their configured value. This
    // will be used at instance time to compute default values for
    // properties that require unique and / or complex initial values:
    var dataInstance = null;

    Polymer.Base.extend(proto, implementation);

    // Properties are copied from the initial configuration directly onto the
    // prototype so that PropertyAccessors sets up protoProps correctly.
    // Properties with a function value are stashed for later:
    for (var property in properties) {
      var config = properties[property];
      var value = config.value;

      if (value instanceof Function) {
        dataInstance = dataInstance || {};
        dataInstance[property] = value;
      } else {
        proto[property] = value;
      }

      proto._createPropertyAccessor(property);
    }

    // Stash the property config on the prototype for later reference in the
    // createdCallback:
    proto.properties = properties;

    // To be used later in createdCallback:
    proto.__dataInstance = dataInstance;

    if (module != null) {
      var template = module.querySelector('template');

      if (template != null) {
        var stylesheet =
            (template._content || template.content).querySelector('style');

        // There is a per-registration weak set to keep track of roots that have
        // been styled for the element.
        proto.__styledRoots = new WeakSet();
        proto.__template = template;

        if (stylesheet != null) {
          proto.__cssText = stylesheet.textContent;

          // We remove the stylesheet from the template so that we do not stamp it
          // again for every element instance.
          stylesheet.parentNode.removeChild(stylesheet);
        } else {
          proto.__cssText = '';
        }
      }
    }

    document.registerElement(is, {
      prototype: proto
    });
  };
})();
</script>
