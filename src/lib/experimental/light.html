<!--
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../../../polymer.html">
<link rel="import" href="property-accessors.html">
<script>
(function() {

  function mapIdNodes(root) {
    var nodes = root.querySelectorAll('[id]');
    var map = {};

    for (var i = 0; i < nodes.length; ++i) {
      map[nodes[i].id] = nodes[i];
    }

    return map;
  }


  // Basic setup of the common base, which includes HTMLElement and
  // the backported PropertyAccessors.
  var base = Polymer.Base.extend(
      Object.create(HTMLElement.prototype),
      Polymer.PropertyAccessors.mixin);

  var light = Polymer.Base.extend(base, {
    createdCallback: function() {
      // Element will not be marked as ready until the first attached
      this.__ready = false;

      // This will set root to a document fragment, if there is a template
      // available to instance:
      this.root = this.__template
          ? Polymer.Base.instanceTemplate(this.__template)
          : null;

      // This method is implemented by PropertyAccessors, and will set
      // properties to their initial values. Change callback should be async,
      // so it is okay to do this before mapping ID nodes:
      this._initializeProperties();

      if (this.root != null) {
        // Queries for nodes with ID and marshal them to the $ property:
        this.$ = mapIdNodes(this.root);
        // No shadow root created, so we just append to the element's light
        // dom. NOTE: no style encapsulation here.
        this.appendChild(this.root);
      }

      if (this.created != null) {
        this.created();
      }
    },

    attachedCallback: function() {
      // This may be the first attach, so we do some one-time work here to
      // set things up:
      if (this.__ready === false) {
        // Find the "owner" root, which may be a shadow root:
        var ownerRoot = this;

        while (ownerRoot
               && ownerRoot.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
          ownerRoot = ownerRoot.parentNode;
        }

        // The location where we will append styles is the owner root if
        // there is one, or else the owner document head.
        var styleParent = ownerRoot != null
          ? ownerRoot
          : this.ownerDocument.head;

        // We only want to append the stylesheet once per light element, so
        // we track the roots that have the stylesheet in a weak set:
        if (!this.__styledRoots.has(styleParent)) {
          var stylesheet = document.createElement('style');

          stylesheet.textContent = this.__cssText;
          styleParent.appendChild(stylesheet);

          this.__styledRoots.add(styleParent);
        }

        // One time readiness work is complete:
        this.__ready = true;

        if (this.ready != null) {
          this.ready();
        }
      }

      if (this.detached != null) {
        this.detached();
      }
    },

    detachedCallback: function() {
      if (this.detached != null) {
        this.detached();
      }
    }
  });


  Polymer.Light = function(implementation) {
    var proto = Object.create(light);
    var is = implementation.is;
    // Properties are slightly different from standard Polymer properties.
    // Only key name and default value are supported, so it should be of the
    // form `properties: { foo: 123, bar: 'bar', baz: true }`
    var properties = implementation.properties;
    var module = Polymer.DomModule.import(is);

    Polymer.Base.extend(proto, implementation);

    // Properties are copied from the initial configuration directly onto the
    // prototype so that PropertyAccessors sets up protoProps correctly:
    for (var property in properties) {
      var value = properties[property];
      proto[property] = value;
      proto._createPropertyAccessor(property);
    }

    if (module != null) {
      var template = module.querySelector('template');

      if (template != null) {
        var stylesheet =
            (template._content || template.content).querySelector('style');

        // There is a per-registration weak set to keep track of roots that have
        // been styled for the element.
        proto.__styledRoots = new WeakSet();
        proto.__template = template;
        proto.__cssText = stylesheet ? stylesheet.textContent : '';

        // We remove the stylesheet from the template so that we do not stamp it
        // again for every element instance.
        stylesheet.parentNode.removeChild(stylesheet);
      }
    }

    document.registerElement(is, {
      prototype: proto
    });
  };
})();
</script>
