<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/path.html">
<link rel="import" href="../utils/mixin.html">

<script>
(function() {
  'use strict';

  const KEYWORDS = ['this', 'true', 'false'];
  const PRECEDENCE = {
      ')': 0,
      ']': 0,
      '}': 0,
      '(': 11,
      '[': 11,
      '{': 11,
  };
  const POSTFIX_PRECEDENCE = 11;

  const UNARY_OPERATORS = ['-', '!'];

  const _UNARY_OPERATORS = {
    '-': (a) => -a,
    '!': (a) => !a,
  };

  const Kind = {};
      Kind[Kind["STRING"] = 1] = "STRING";
      Kind[Kind["IDENTIFIER"] = 2] = "IDENTIFIER";
      Kind[Kind["DOT"] = 3] = "DOT";
      Kind[Kind["COMMA"] = 4] = "COMMA";
      Kind[Kind["INTEGER"] = 6] = "INTEGER";
      Kind[Kind["DECIMAL"] = 7] = "DECIMAL";
      Kind[Kind["GROUPER"] = 9] = "GROUPER";
      Kind[Kind["KEYWORD"] = 10] = "KEYWORD";
  function token(kind, value, precedence) {
      return {
          kind: kind,
          value: value,
          precedence: precedence || 0,
      };
  }
  function _isWhitespace(ch) {
      return ch === 9 /* \t */ ||
          ch === 10 /* \n */ ||
          ch === 13 /* \r */ ||
          ch === 32 /* space */;
  }
  // TODO(justinfagnani): allow code points > 127
  function _isIdentOrKeywordStart(ch) {
      return _isIdentifier(ch) || ch === 95 /* _ */ || ch === 36 /* $ */;
  }
  // TODO(justinfagnani): allow code points > 127
  function _isIdentifier(ch) {
      ch &= ~32;
      return 65 /* A */ <= ch && ch <= 90 /* Z */ || ch === 26 /* : */ || ch === 10 /* * */ || ch === 45 /* - */;
  }
  function _isKeyword(str) {
      return KEYWORDS.indexOf(str) !== -1;
  }
  function _isQuote(ch) {
      return ch === 34 /* " */ || ch === 39 /* ' */;
  }
  function _isNumber(ch) {
      return 48 /* 0 */ <= ch && ch <= 57 /* 9 */ || ch === 45 /* - */;
  }
  function _isOperator(ch) {
    return ch === 45 /* - */ ||
        ch === 42 /* * */ ||
        ch === 33 /* ! */;
}
  function _isGrouper(ch) {
      return ch === 40 /* ( */ ||
          ch === 41 /* ) */ ||
          ch === 91 /* [ */ ||
          ch === 93 /* ] */ ||
          ch === 123 /* { */ ||
          ch === 125 /* } */;
  }
  function _escapeString(str) {
      return str.replace(/\\(.)/g, function (_match, group) {
          switch (group) {
              case 'n':
                  return '\n';
              case 'r':
                  return '\r';
              case 't':
                  return '\t';
              case 'b':
                  return '\b';
              case 'f':
                  return '\f';
              default:
                  return group;
          }
      });
  }
  class Tokenizer {
      constructor(input) {
          this._index = -1;
          this._tokenStart = 0;
          this._next = null;
          this._input = input;
      }
      nextToken() {
          if (this._index === -1)
              this._advance();
          while (_isWhitespace(this._next)) {
              this._advance(true);
          }
          if (_isQuote(this._next))
              return this._tokenizeString();
          if (_isIdentOrKeywordStart(this._next)) {
            return this._tokenizeIdentOrKeyword();
          }
          if (_isNumber(this._next))
              return this._tokenizeNumber();
          if (this._next === 46 /* . */)
              return this._tokenizeDot();
          if (this._next === 44 /* , */)
              return this._tokenizeComma();
          if (_isOperator(this._next))
            return this._tokenizeOperator();
          if (_isGrouper(this._next))
              return this._tokenizeGrouper();
          // no match, should be end of input
          this._advance();
          if (this._next) {
              throw new Error(`Expected end of input, got ${this._next}`);
          }
          return null;
      }
      _advance(resetTokenStart) {
          if (this._index < this._input.length) {
              this._index++;
              this._next = this._input.charCodeAt(this._index);
              if (resetTokenStart) {
                  this._tokenStart = this._index;
              }
          }
          else {
              this._next = null;
          }
      }
      _getValue(lookahead) {
          const v = this._input.substring(this._tokenStart, this._index + (lookahead || 0));
          if (!lookahead)
              this._clearValue();
          return v;
      }
      _clearValue() {
          this._tokenStart = this._index;
      }
      _tokenizeString() {
          const _us = 'unterminated string';
          const quoteChar = this._next;
          this._advance(true);
          while (this._next !== quoteChar) {
              if (!this._next)
                  throw new Error(_us);
              if (this._next === 92 /* \ */) {
                  this._advance();
                  if (!this._next)
                      throw new Error(_us);
              }
              this._advance();
          }
          const t = token(Kind.STRING, _escapeString(this._getValue()));
          this._advance();
          return t;
      }
      _tokenizeIdentOrKeyword() {
          while (_isIdentifier(this._next)) {
              this._advance();
          }
          const value = this._getValue();
          const kind = _isKeyword(value) ? Kind.KEYWORD : Kind.IDENTIFIER;
          return token(kind, value);
      }
      _tokenizeNumber() {
          while (_isNumber(this._next)) {
              this._advance();
          }
          if (this._next === 46 /* . */)
              return this._tokenizeDot();
          return token(Kind.INTEGER, this._getValue());
      }
      _tokenizeDot() {
          this._advance();
          if (_isNumber(this._next))
              return this._tokenizeFraction();
          this._clearValue();
          return token(Kind.DOT, '.', POSTFIX_PRECEDENCE);
      }
      _tokenizeComma() {
          this._advance(true);
          return token(Kind.COMMA, ',');
      }
      _tokenizeOperator() {
        this._advance();
        const op = this._getValue();
        return token(Kind.OPERATOR, op, constants_1.PRECEDENCE[op]);
      }
      _tokenizeGrouper() {
          const value = String.fromCharCode(this._next);
          const t = token(Kind.GROUPER, value, PRECEDENCE[value]);
          this._advance(true);
          return t;
      }
  }

  class EvalAstFactory {
    empty() {
        // TODO(justinfagnani): return null instead?
        return {
            type: 'Empty',
            evaluate(scope) {
                return scope;
            },
            getIds(idents) {
                return idents;
            },
        };
    }
    // TODO(justinfagnani): just use a JS literal?
    literal(v) {
        return {
            type: 'Literal',
            value: v,
            evaluate(_scope) {
                return this.value;
            },
            getIds(idents) {
                return idents;
            },
        };
    }
    id(v) {
        return {
            type: 'ID',
            value: v,
            evaluate(scope) {
                // TODO(justinfagnani): this prevernts access to properties named 'this'
                if (this.value === 'this') {
                  return scope;
                }
                if (this.value === 'true') {
                  return true;
                }
                if (this.value === 'false') {
                  return false;
                }
                return scope[this.value];
            },
            getIds(idents) {
                idents.push(this.value);
                return idents;
            },
        };
    }
    unary(op, expr) {
        const f = UNARY_OPERATORS[op];
        return {
            type: 'Unary',
            operator: op,
            child: expr,
            evaluate(scope) {
                return f(this.child.evaluate(scope));
            },
            getIds(idents) {
                return this.child.getIds(idents);
            },
        };
    }
    getter(g, n) {
        return {
            type: 'Getter',
            receiver: g,
            name: n,
            evaluate(scope) {
                return this.receiver.evaluate(scope)[this.name];
            },
            getIds(idents) {
                this.receiver.getIds(idents);
                return idents;
            },
        };
    }
    invoke(receiver, method, args) {
        if (method != null && typeof method !== 'string') {
            throw new Error('method not a string');
        }
        return {
            type: 'Invoke',
            receiver: receiver,
            method: method,
            arguments: args,
            evaluate(scope) {
                const receiver = this.receiver.evaluate(scope);
                // TODO(justinfagnani): this might be wrong in cases where we're
                // invoking a top-level function rather than a method. If method is
                // defined on a nested scope, then we should probably set _this to null.
                const _this = this.method ? receiver : scope['this'] || scope;
                const f = this.method ? receiver[method] : receiver;
                const args = this.arguments || [];
                const argValues = args.map((a) => (a && a.evaluate(scope)));
                return f.apply(_this, argValues);
            },
            getIds(idents) {
                this.receiver.getIds(idents);
                (this.arguments || []).forEach((a) => (a && a.getIds(idents)));
                return idents;
            },
        };
    }
}

function parse(expr, astFactory) {
    return new Parser(expr, astFactory).parse();
}
class Parser {
    constructor(input, astFactory) {
        this._kind = null;
        this._token = null;
        this._value = null;
        this._tokenizer = new Tokenizer(input);
        this._ast = astFactory;
    }
    parse() {
        this._advance();
        return this._parseExpression();
    }
    _advance(kind, value) {
        if (!this._matches(kind, value)) {
            throw new Error(`Expected kind ${kind} (${value}), was ${this._token}`);
        }
        const t = this._tokenizer.nextToken();
        this._token = t;
        this._kind = t && t.kind;
        this._value = t && t.value;
    }
    _matches(kind, value) {
        return !(kind && (this._kind !== kind) || value && (this._value !== value));
    }
    _parseExpression() {
        if (!this._token)
            return this._ast.empty();
        return this._parsePrecedence(this._parsePrimary(), 0);
    }
    // _parsePrecedence and _parseBinary implement the precedence climbing
    // algorithm as described in:
    // http://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method
    _parsePrecedence(left, precedence) {
        if (!left) {
            throw new Error('Expected left not to be null.');
        }
        while (this._token) {
            if (this._matches(Kind.GROUPER, '(')) {
                const args = this._parseArguments();
                left = this._ast.invoke(left, null, args);
            }
            else if (this._matches(Kind.GROUPER, '[')) {
                const indexExpr = this._parseIndex();
                left = this._ast.index(left, indexExpr);
            }
            else if (this._matches(Kind.DOT)) {
                this._advance();
                const right = this._parsePrimary();
                left = this._makeInvokeOrGetter(left, right);
            }
            else if (this._matches(Kind.DOT)) {
                this._advance();
                const right = this._parsePrimary();
                left = this._makeInvokeOrGetter(left, right);
            }
            else if (this._matches(Kind.KEYWORD)) {
                break;
            }
            else {
                break;
            }
        }
        return left;
    }
    _makeInvokeOrGetter(left, right) {
        if (right.type === 'ID') {
            return this._ast.getter(left, right.value);
        }
        else if (right.type === 'Invoke' && right.receiver.type === 'ID') {
            const method = right.receiver;
            return this._ast.invoke(left, method.value, right.arguments);
        }
        else {
            throw new Error(`expected identifier: ${right}`);
        }
    }
    _parsePrimary() {
        switch (this._kind) {
            case Kind.KEYWORD:
                const keyword = this._value;
                if (keyword === 'this') {
                    this._advance();
                    // TODO(justin): return keyword node
                    return this._ast.id(keyword);
                }
                else if (KEYWORDS.indexOf(keyword) !== -1) {
                    throw new Error(`unexpected keyword: ${keyword}`);
                }
                throw new Error(`unrecognized keyword: ${keyword}`);
            case Kind.IDENTIFIER:
                return this._parseInvokeOrIdentifier();
            case Kind.STRING:
                return this._parseString();
            case Kind.INTEGER:
                return this._parseInteger();
            case Kind.DECIMAL:
                return this._parseDecimal();
            case Kind.GROUPER:
                if (this._value === '(') {
                    return this._parseParen();
                }
                return null;
            case Kind.COLON:
                throw new Error('unexpected token ":"');
            default:
                return null;
        }
    }
    _parseInvokeOrIdentifier() {
        const value = this._value;
        if (value === 'true') {
            this._advance();
            return this._ast.literal(true);
        }
        if (value === 'false') {
            this._advance();
            return this._ast.literal(false);
        }
        if (value === 'null') {
            this._advance();
            return this._ast.literal(null);
        }
        const identifier = this._parseIdentifier();
        const args = this._parseArguments();
        return (!args) ? identifier : this._ast.invoke(identifier, null, args);
    }
    _parseIdentifier() {
        if (!this._matches(Kind.IDENTIFIER)) {
            throw new Error(`expected identifier: ${this._value}`);
        }
        const value = this._value;
        this._advance();
        return this._ast.id(value);
    }
    _parseArguments() {
        if (this._matches(Kind.GROUPER, '(')) {
            const args = [];
            do {
                this._advance();
                if (this._matches(Kind.GROUPER, ')')) {
                    break;
                }
                const expr = this._parseExpression();
                args.push(expr);
            } while (this._matches(Kind.COMMA));
            this._advance(Kind.GROUPER, ')');
            return args;
        }
        return null;
    }
    _parseIndex() {
        if (this._matches(Kind.GROUPER, '[')) {
            this._advance();
            const expr = this._parseExpression();
            this._advance(Kind.GROUPER, ']');
            return expr;
        }
        return null;
    }
    _parseParen() {
        this._advance();
        const expr = this._parseExpression();
        this._advance(Kind.GROUPER, ')');
        return this._ast.paren(expr);
    }
    _parseString() {
        const value = this._ast.literal(this._value);
        this._advance();
        return value;
    }
    _parseInteger(prefix) {
        prefix = prefix || '';
        const value = this._ast.literal(parseInt(`${prefix}${this._value}`, 10));
        this._advance();
        return value;
    }
    _parseDecimal(prefix) {
        prefix = prefix || '';
        const value = this._ast.literal(parseFloat(`${prefix}${this._value}`));
        this._advance();
        return value;
    }
}

  /**
   * Mixin that parses binding expressions and generates corresponding metadata.
   * The implementation is different than in `property-effects`, as it uses a
   * state machine instead of a regex. As such, this implementation is able to
   * handle more cases, with the potential performance hit.
   *
   * @namespace
   * @memberof Polymer
   * @summary Mixin that parses binding expressions and generates corresponding metadata.
   */
  const StrictBindingParser = Polymer.dedupingMixin((base) => {

    const astFactory = new EvalAstFactory();

    return class extends base {

      /**
       * Called to parse text in a template (either attribute values or
       * textContent) into binding metadata.
       *
       * Any overrides of this method should return an array of binding part
       * metadata  representing one or more bindings found in the provided text
       * and any "literal" text in between.  Any non-literal parts will be passed
       * to `_evaluateBinding` when any dependencies change.  The only required
       * fields of each "part" in the returned array are as follows:
       *
       * - `dependencies` - Array containing trigger metadata for each property
       *   that should trigger the binding to update
       * - `literal` - String containing text if the part represents a literal;
       *   in this case no `dependencies` are needed
       *
       * Additional metadata for use by `_evaluateBinding` may be provided in
       * each part object as needed.
       *
       * The default implementation handles the following types of bindings
       * (one or more may be intermixed with literal strings):
       * - Property binding: `[[prop]]`
       * - Path binding: `[[object.prop]]`
       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
       * - Two-way property or path bindings (supports negation):
       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
       * - Inline computed method (supports negation):
       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
       *
       * @param {string} text Text to parse from attribute or textContent
       * @param {Object} templateInfo Current template metadata
       * @return {Array<!BindingPart>} Array of binding part metadata
       * @protected
       */
      static _parseBindings(text, templateInfo) {
        let startIndex = text.indexOf('[[');
        let char = ']'
        if (startIndex === -1) {
          startIndex = text.indexOf('{{');
          char = '}'
        }
        if (startIndex !== -1) {
          let endIndex = text.indexOf(char + char);
          if (endIndex !== -1) {
            try {
              let ast = parse(text.slice(startIndex + 2, endIndex), astFactory);
              return [{ast, text, dependencies: ast.getIds([])}];
            } catch (e) {
              // debugger;
            }
          }
        }
        return null;
      }

      static _evaluateBinding(scope, part, path, props, oldProps, hasPaths) {
        if (part.ast) {
          try {
            return part.ast.evaluate(scope);
          } catch (e) {
            return null;
          }
        } else {
          return super._evaluateBinding(scope, part, path, props, oldProps, hasPaths);
        }
      }
    };
  });

  Polymer.StrictBindingParser = StrictBindingParser;
})();
</script>
